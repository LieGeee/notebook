### 1. 为什么要这个机制？（核心痛点：歧义）

在 Go 语言里，任何变量都有默认值（Zero Value）：

- `int` 默认是 `0`
    
- `bool` 默认是 `false`
    
- `string` 默认是 `""`
    

**场景：** 假设你有一个用户表，用户 `Age` 是 25 岁。现在你要更新他的 `Name`。

```Go
type User struct {
    Name string
    Age  int
}

// 前端只传了 Name = "张三"，没传 Age
user := User{Name: "张三"} 
// 此时 user.Age 是多少？ 是 0 (Go 自动给的)
```

如果没有“忽略零值”机制，GORM 会怎么做？

它会生成 SQL：UPDATE users SET name='张三', age=0;

💥 灾难发生了！ 用户只是改个名，结果年龄被重置成 0 岁了。

**所以 GORM 制定了规则：**

> “如果我看到一个字段是 `0`、`false` 或 `""`，我**不敢确定**这是用户真的想改成 0，还是用户压根没填。为了安全，我**默认不更新**这个字段。”

---

### 2. 那是指针类型的就得存 Null 吗？（指针的作用）

这就引出了你的问题：怎么解决这种歧义？

答案就是引入 指针 (*int, *bool)。指针多了一个状态：nil。

使用指针后，我们就有了 **3 种状态**，完美对应数据库逻辑：

|**Go 指针状态**|**含义**|**GORM 的行为**|**SQL 结果**|
|---|---|---|---|
|`nil`|**“我没填”** (Undefined)|忽略，不更新|(不生成 SQL 字段)|
|指向 `0` / `false`|**“我要改成 0”** (Value)|**强制更新**|`SET age=0`|
|指向 `10` / `true`|**“我要改成 10”** (Value)|正常更新|`SET age=10`|

**回到你的问题：**

- **不是“得存 null”**：而是如果前端没传这个值，它就是 `nil`，数据库就不改。
    
- **如果是 0 或 false**：因为是指针指向了 `0`（而不是 `nil`），GORM 知道“哦！这是个实实在在的 0”，它就会放心大胆地去更新数据库。
    

---

### 3. 还有什么机制？（除了指针还能怎么搞？）

除了把字段改成指针（这会让代码里充满 `*`，有时候很烦），GORM 还提供了其他几种机制来“绕过”零值检查：

#### 机制 A：指定列名 `Update` / `Updates` (你之前的代码用的就是这个)

这是最霸道的方式。

```Go
// 明确告诉 GORM：我就要改 "has_guided" 这一列，不管值是什么！
db.Model(&user).Update("has_guided", false)
```

- **优点**：精准，安全。
    
- **缺点**：一次只能改一两个字段，字段多了写起来累。
    

#### 机制 B：使用 Map (`map[string]interface{}`)

Map 没有默认值的问题。key 存在就是存在，不存在就是不存在。

```Go
// map 里有什么就改什么
db.Model(&user).Updates(map[string]interface{}{
    "name":       "李四",
    "has_guided": false, // 这里传 false，GORM 会更新！因为 map 里明确有这个 key
})
```

- **优点**：灵活，支持批量更新零值。
    
- **缺点**：失去了结构体的类型检查（写错了字段名 key 编译器不会报错）。
    

#### 机制 C：`Select` / `Omit` (白名单/黑名单)

你可以配合结构体使用，明确告诉 GORM 选哪些字段。

```Go
user := User{Name: "王五", Age: 0}
// 强行更新 Age，即使它是 0
db.Model(&user).Select("Name", "Age").Updates(user)
```

---

### 4. 总结与记忆

|**这里的 "0/false"**|**指针类型 *T**|**值类型 T (int/bool)**|**Map**|
|---|---|---|---|
|**含义**|指向 0 的指针|就是 0|Key 对应的值是 0|
|**GORM 反应**|"这是用户设定的 0" -> **更新**|"这可能是默认值" -> **忽略**|"Key 都在这了" -> **更新**|
|**适用场景**|需要区分"未填"和"0"|字段必填且非 0，或用作查询结果|动态更新，补丁操作 (Patch)|

你的困惑解决了吗？

你之前的代码用了 Update("has_guided", guided)，这属于 机制 A。这是最稳妥的做法，因为它完全避开了“零值歧义”的问题，直接下达了精确指令。