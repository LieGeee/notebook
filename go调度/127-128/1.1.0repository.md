在开发流程中，继数据库迁移（Migration）之后，紧接着创建 **Model（数据模型）** 是因为它是连接 **“数据库（SQL世界）”** 和 **“代码逻辑（Go世界）”** 的桥梁，也是后续所有代码的基础。

简单来说：**如果没有 Model，后面的 Repository（仓库层）和 Service（业务层）连函数的入参和返回值都写不出来。**

以下是具体的 3 个核心原因：

### 1. 它是代码层面的“地基”（依赖关系）

在 Go 语言这种强类型语言中，数据必须有明确的结构定义（Struct）。

请看你提供的代码结构，依赖链条是这样的：

- **Repository 层**（Step 3）引用了 Model： `func Create(ctx context.Context, link *model.ShortLink) error`
    
- **Service 层**（Step 4）引用了 Model： `func GetByCode(...) (*model.ShortLink, error)`
    

**结论**：如果你不先写 `model/short_link.go`，当你去写 Step 3 的 Repository 代码时，编译器会直接报错，提示 `model.ShortLink` 未定义。为了让代码能顺畅地从下往上写，必须先定义好这个结构体。

### 2. 它是 ORM（GORM）的“映射说明书”

在 Step 1 中，你创建了 SQL 表 `sys_shortlinks`。但在 Go 代码里，程序并不知道这张表长什么样。

Model 文件的作用就是告诉 GORM 框架：

- Go 里的 `ID` 对应数据库里的 `id` 字段。
    
- Go 里的 `Code` 对应数据库里的 `code` 字段。
    
- Go 里的结构体 `ShortLink` 对应数据库里的表 `sys_shortlinks`（通过 `TableName()` 方法指定）。
    

Go

```
// 这一步就是把 SQL 表变成了 Go 能操作的对象
type ShortLink struct {
    Code string `gorm:"uniqueIndex;..."` // 告诉 GORM 这里有个唯一索引
}
```

### 3. 确立“业务语言”

先定义 Model 有助于你在写业务逻辑之前，再次确认数据结构是否合理。

- **例子**：你在 Step 1 的 SQL 里定义了 `expire_at`。
    
- 在 Step 2 写 Model 时，你定义了 `ExpireAt time.Time`。
    
- 这让你在后续写 Service（Step 4）时，很自然地知道要处理的是时间类型，而不是字符串或整数。
    

---

### 总结：开发流顺畅的关键

这个顺序（Migration -> Model -> Repo -> Service ...）是为了让你**由内向外**、**由底向上**地构建系统：

1. **数据库 (SQL)**：先把坑挖好。
    
2. **Model (Struct)**：定义砖头的规格（映射 SQL）。
    
3. **Repository (DAO)**：定义怎么搬砖（增删改查）。
    
4. **Service (Logic)**：定义用砖头盖什么房子（业务逻辑）。
    
5. **Handler (API)**：把房子展示给用户看（HTTP 接口）。
    

这样每一步都建立在上一步完成的基础上，写代码时 IDE 还能给你自动补全，开发体验最顺畅。