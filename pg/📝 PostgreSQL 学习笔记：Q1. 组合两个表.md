# 📝 PostgreSQL 学习笔记：Q1. 组合两个表

## 1. 核心知识点：外联结 (Outer Join)

在处理多表查询时，如果我们希望**保留主表的所有记录**，即使在关联表中找不到对应数据，就必须使用外联结。

- **LEFT JOIN (左联结)**：保留 `FROM` 子句中左侧表的所有行。
- **ON vs WHERE**：
  - `ON` 是连接条件，决定数据如何“对齐”。
  - `WHERE` 是过滤条件，在连接完成后筛选结果。

------

## 2. 题目解析

**目标**：查询所有人的姓名及其地址信息。如果某人没有地址，地址字段显示为 `null`。

### ✅ 推荐解法 (SQL)

SQL

```
SELECT 
    p.firstName, 
    p.lastName, 
    a.city, 
    a.state
FROM Person p
LEFT JOIN Address a
ON p.personId = a.personId;
```

> **💡 小贴士**：使用别名（`p` 和 `a`）可以极大地提高代码的可读性和编写速度。

------

## 3. 核心知识卡片 🗂️

| **维度**       | **内容**                                                     |
| -------------- | ------------------------------------------------------------ |
| **关键词** 🔑   | `LEFT JOIN ... ON`                                           |
| **口诀** 🎵     | 左表全留，右表补漏；对不上号，NULL来凑。                     |
| **适用场景** 🏗️ | 统计“所有用户”的订单、“所有学生”的成绩（包括缺考者）等。     |
| **必坑指南** ⚠️ | 1. 检查关联键（如 `personId`）在两表中的类型是否一致。 2. 区分左联结和内联结（Inner Join）的区别。 |

------

## 4. 大数据量扩展思考 🚀

当数据量从几百条增长到**千万级**甚至**亿级**时，简单的查询会变慢：

1. **索引优化 (Indexing)** ⚡
   - 在 `JOIN` 使用的关联字段（`personId`）上建立索引。PostgreSQL 会利用索引进行 **Index Scan** 或 **Hash Join**。
2. **执行计划 (Explain)** 🔍
   - 使用 `EXPLAIN ANALYZE` 查看数据库底层是怎么跑的，确认是否发生了全表扫描。
3. **连接算法选择** 🧠
   - **Hash Join**：适合一个大表联结一个小表（把小表放内存）。
   - **Merge Join**：如果两个表都已经按关联键排序，这是最快的联结方式。
4. **表分区 (Partitioning)** 📦
   - 如果 `Person` 表巨大，可以按 ID 范围进行分区，查询时只需扫描特定的分区。